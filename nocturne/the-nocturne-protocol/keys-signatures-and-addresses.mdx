---
title: "Keys, Signatures, and Addresses"
description: "Details about algebraic primitives, key derivation, canonical address, address re-randomization, and signatures"
---

## Algebraic Primitives

Unless otherwise specified, all values are assumed to be elements of the Scalar field of BN254 as defined in [EIP-197](https://eips.ethereum.org/EIPS/eip-197). We will refer to this field as the "BN254 Scalar field" or  for short. We will use  to refer to the order of the BN254 scalar field.

For all elliptic curve cryptography, including our addressing and signature schemes, we use the Baby Jubjub curve, the curve whose base field is Fp as defined in [EIP-2494](https://eips.ethereum.org/EIPS/eip-2494). All operations are performed in Baby Jubjub's prime-order subgroup, which we will refer to as "Baby Jubjub", or G (blackboard "G" as opposed to regular "G") for short.

We will use r to refer to the order of Baby Jubjub's scalar field (again, the prime-order subgroup, not the curve group), and we will refer that scalar field as "Baby Jubjub Scalar field", or Fr for short.

We will use additive notation. More specifically we use...

- "+" to denote curve addition or field addition depending on whether we are adding curve elements or field elements
- "•" or juxtaposition to denote field multiplication
- "✕" to denote scalar multiplication, in order to clearly distinguish it from field multiplication

Furthermore, we will use all-capital letters for curve elements and all-lowercase lettrs for field elements.

## Hashing
We use the Poseidon hash function defined over the Fp, the BN254 scalar field, instantiated using the [parameters set in `circomlib`'s implementation](https://github.com/iden3/circomlib/blob/master/circuits/poseidon_constants.circom). We will denote this function H. 

## Key Derivation
The user's [spending key](/nocturne-the-nocturne-protocol/keys-and-stealth-addresses), which we will refer to as , is a secure-random element of .

> In Nocturne's MetaMask Snap, we derive the  using the snap_getBip44Entropy method at derivation path m / 44' / 6789'. 

Let G denote the generator of Baby Jubjub.  The user's spending public key, which we will refer to as PK, is an element of Baby Jubjub defined as PK = sk X G. This is only used in the context of signatures to be verified in-circuit. It never appears on-chain or leaves the client.

The user's [viewing key](/nocturne-the-nocturne-protocol/keys-and-stealth-addresses) is an element of Fr defined as sk = H(PK.X ∣∣ PK.Y ∣∣ vkNonce), where PK.X,PK.Y∈Fp are the x and y coordinates of PK respectively, vkNonce∈Fp, and vkNonce must be chosen such that the output of the hash is an element of Fr.

That last provision is needed because H returns an element of Fp, but we need an element of Fr. A reduction modulo r would bias the key generation, and using Poseidon over Fr would be prohibitively expensive in-circuit. But this approach suffers from neither issue - during key generation, we can increment vkNonce and try again if the output of the hash is not an element of Fr. 

> In theory, rejection sampling like this does come at a small performance cost. ~91% of the possible vkNonce>r, so we expect that, on average, it will take 10-11 tries to find a "good" nonce. In practice, the cost is negligible - 11 attempts takes ~30ms with a very naive implementation.

## Addresses

A user's [canonical address](/nocturne/the-nocturne-protocol/keys-and-stealth-addresses), which we will refer to as "the user's canonical address", or C for short, is a Baby Jubjub curve element defined as C=vk×G. 

A user's [stealth address]((/nocturne/the-nocturne-protocol/keys-and-stealth-addresses)) is any pair of Baby Jubjub points (H1,H2)∈gG2 such that vk × H1 = H2. There are many stealth addresses for any given user. Without any other information, the association between any two stealth addresses cannot be determined without access to the underlying viewing key.

Before randomizing a user's canonical address C, it needs to be mapped to a pair of points C→(G,C). We refer to this (G,C) pair as the "canonical stealth address" even though it's not really a "stealth address" because we haven't randomized it yet.

To randomize a stealth address pair S = (H1,H2), we sample a random scalar s←Fr and scalar-multiply into both curve elements, i.e. S` = (sXH1, s×H2). Note that any user may randomize any stealth address without knowing the underlying viewing key or canonical address. All they need is a random number generator and an existing stealth address. We sometimes call this "re-randomization".

Given a user's viewing key vk, we say the vk "owns" a stealth address if the address was generated from . This is true if and only if the following equation holds true:

8 × (vk × H1 - H2) = (0,1)

By (0,1), we specifically mean the curve point (0,1), which is the "zero", or "additive identity" element of Baby Jubjub's curve group (not the prime-order subgroup). This gives the user a way to trace their own transactions.

> The high level intuition behind this is that, each time we randomize a stealth address, we're effectively sending both points to a new coset of Baby Jubjub's prime-order subgroup. It's easy to see that, for any stealth address generated using viewing key vk - including the canonical stealth address - if H1 is in the coset with index X, then H2 is in the coset with index vk X X. Therefore, if we know the user's viewing key, checking if vk owns a stealth address is equivalent to checking if vk × H1 is in the same coset as H2. And that is equivalent to the equation above.

## Signatures

Nocturne uses Schnorr signatures over Baby Jubjub. The secret key is the spending key sk, and the public key is the spending public key PK. 
Spelled out, signing takes as input the message m and proceeds as follows:

1. n←Fr
2. R:=n×G
3. C:=H(PK.X||R.X||R.Y||m)
4. z:=n-sk⋅c
5. The signature is the pair (c,z)

To verify, we take as input the message m and signature (c,z) and do the following:

1. n←Fr
2. R:=n×G
3. c:= H(PK.X||R.X||R.Y||m)
4. z:=n-sk⋅c
5. THe signature is the pair (c,z)

To verify, we take as input the message m and signature (c,z) and do the following:

1. Z:=z×G
2. P:=c×PK
3. R:=Z+PK
4. cp:=H(PK.X ∣∣ R.X ∣∣ R.Y ∣∣ m)
5. Accept the signature if cp=c. Otherwise, it's invalid. 

​
 
